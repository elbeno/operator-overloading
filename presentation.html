<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Operator Overloading</title>
<meta name="author" content="(Ben Deane)"/>
<style type="text/css">
.underline { text-decoration: underline; }
</style>
<link rel="stylesheet" href="../reveal.js/css/reveal.css"/>

<link rel="stylesheet" href="../reveal.js/css/theme/blood.css" id="theme"/>

<link rel="stylesheet" href="./presentation.css"/>

<link rel="stylesheet" href="./emoji.css"/>

<!-- If the query includes 'print-pdf', include the PDF print sheet -->
<script>
    if( window.location.search.match( /print-pdf/gi ) ) {
        var link = document.createElement( 'link' );
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = '../reveal.js/css/print/pdf.css';
        document.getElementsByTagName( 'head' )[0].appendChild( link );
    }
</script>
</head>
<body>
<div class="reveal">
<div class="slides">
<section id="sec-title-slide"><div class='vertspace6'/><h2>Operator Overloading</h2><h3>History, Principles and Practice</h3></div><h3>Ben Deane / <a href="http://twitter.com/ben_deane">@ben_deane</a></h3><h4>CppCon / Tuesday September 25th, 2018</h4>
</section>
<script type="text/javascript" src="./presentation.js"></script>

<section>
<section id="slide-orgb7537e6">
<h2 id="orgb7537e6">First: Operators I'm Not Talking About</h2>
<ul>
<li>conversions (e.g. <code>operator int()</code>)</li>
<li>user-defined literals (e.g. <code>operator ""_km</code>)</li>
<li><code>operator new</code> and <code>operator delete</code></li>
<li>assignment</li>

</ul>

<p>
I'll mostly be talking about "mathematical" operators (arithmetic, bitwise,
equality, etc).
</p>

<aside class="notes">
<p>
I'm going to be talking about <i>why</i> we should embrace operator overloading.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgdebd18b">
<h2 id="orgdebd18b">Operators in C++</h2>
<p>
They just aren't very good. Things we can't control:
</p>

<ul>
<li class="fragment appear">name</li>
<li class="fragment appear">precedence</li>
<li class="fragment appear">associativity</li>
<li class="fragment appear">arity</li>
<li class="fragment appear">fixity</li>
<li class="fragment appear">evaluation semantics</li>

</ul>

<aside class="notes">
<p>
Basically, operators in C++ were fixed to a large extent in 1969 when Ken
Thompson invented B.
</p>

<p>
The syntax is fixed - we don't get to introduce new operators (e.g. power).
Precedence rules often give us a very short list of operators to choose from if
we want to overload. Associativity can be a problem in overloading some
operators. We don't get arity choices (if you think this is an odd thing to
want, consider the utility in making some binary operators unary and read Ken
Iverson's 1979 Turing Award Lecture). We don't get a choice whether to make an
operator infix, prefix or postfix. For some operators evaluation semantics are
fixed.
</p>

<p>
OK, so why do we care and what can we do about it with the power that we do
have?
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org4e6a9be">
<h2 id="org4e6a9be">Motivation</h2>
<p>
The obvious first question:
</p>

<p>
Why should we use operators at all?
</p>

</section>
<section id="slide-org1a36eee">
<h3 id="org1a36eee">Why?</h3>
<ul>
<li class="fragment appear">for concision?</li>
<li class="fragment appear">for performance?</li>
<li class="fragment appear">to take advantage of ADL?</li>
<li class="fragment appear">because we can?</li>
<li class="fragment appear">because we have to (equality/ordering)?</li>

</ul>

<aside class="notes">
<p>
For some or all of these reasons?
</p>

<p>
Sometimes we "have to" overload operators because we want to put our types in
a particular type of container that requires it, for example a set.
</p>

</aside>

</section>
<section id="slide-orgcf85ab8">
<h3 id="orgcf85ab8">Why?</h3>
<p>
Because operators <i>convey meaning about types</i> that named functions don't.
</p>

<div class="org-src-container">

<pre  class="src src-c++">a + b + c;
</pre>
</div>

<aside class="notes">
<p>
A grade-school child can intuit properties of addition.
</p>

<p>
Before we learn the names for mathematical properties - commutativity,
associativity, closedness, identity, etc. - we intuit these things. And we learn
this notation.
</p>

<p>
Addition is perhaps the canonical operator for this reason.
</p>

</aside>

</section>
<section id="slide-orgdf4e5cc">
<h3 id="orgdf4e5cc">Say this another way&#x2026;</h3>
<blockquote nil>
<p>
"It is probably wise to use operator overloading primarily to mimic conventional
use of operators."
</p>
<div></div><div class='author'>
<p>
&#x2013; Bjarne Stroustrup, <i>The C++ Programming Language</i>
</p>
</div>
</blockquote>

<aside class="notes">
<p>
We had better be conventional. But what is convention?
</p>

</aside>

</section>
<section id="slide-org30b2e0e">
<h3 id="org30b2e0e">The History Part</h3>
<p>
Or, counterpoint to "stick to convention".
</p>

<p>
Because things haven't always been this way.
</p>


<div class="figure">
<p><img src="camera.jpg" alt="camera.jpg" width="500px" />
</p>
</div>

<font size="3">By Joffboff - Own work, CC BY-SA 4.0, https://commons.wikimedia.org/w/index.php?curid=56389131</font>

<aside class="notes">
<p>
"What I'm used to" can mean "this is the only thing I've experienced". One
person's convention can be unknown to another. Often things are just a matter of
familiarity.
</p>

<p>
This is the Canon Digital Ixus (Elph). This was the first digital camera I
owned, because this was the point when digital cameras really started to get
good. Even saying "digital" camera sounds today like an anachronism. The only
time this sees use any more is when people need to save their phone battery.
</p>

<p>
Wikipedia tells me this camera was released in 2000. It's older than some C++
programmers.
</p>

</aside>

</section>
<section id="slide-org551d85b">
<h3 id="org551d85b">I 3D-printed a Save Icon!</h3>

<div class="figure">
<p><img src="floppy.png" alt="floppy.png" width="500px" />
</p>
</div>

<aside class="notes">
<p>
Convention is weird, isn't it?
</p>

</aside>

</section>
<section id="slide-org7a0ef64">
<h3 id="org7a0ef64">What is "convention" in history?</h3>
<p>
What we may think of as "axiomatic" - mathematical notation -<br />
is actually changing all the time.
</p>

<ul>
<li>Nicole Oresme</li>
<li>Robert Recorde</li>
<li>William Oughtred</li>
<li>Gottfried Wilhelm Leibniz</li>

</ul>

<aside class="notes">
<p>
In particular these four mathematicians are famous for (among other things)
inventing and/or popularising notations.
</p>

<p>
But, you say, that's ancient history&#x2026;
</p>

</aside>

</section>
<section id="slide-org350bb07">
<h3 id="org350bb07">What's the answer?</h3>
<div class='vertspace2'></div>
<h1>355 / 113 = ?</h1>
<p class="fragment (appear)">
Are you sure?
</p>

<aside class="notes">
<p>
Until about the turn of the 20th century, : was in common use to mean division.
We still use it today when expressing ratios.
</p>

<p>
A "division sign" is the horizontal line with dots either side. e.g. unicode.
</p>

<p>
A mathematician would probably write a fraction as one number on top of another
rather than side-by-side separated by a slash.
</p>

<p>
As far as I can tell this sign means "division" fairly recently and because of
computer terminal limitations.
</p>

</aside>

</section>
<section id="slide-org0d812bc">
<h3 id="org0d812bc">What do these mean?</h3>
<div class='vertspace2'></div>
<h1>% ^ ~ |</h1>
<p class="fragment (appear)">
These are really arbitrary and only a little older than me.
</p>

<aside class="notes">
<p>
As far as I can tell, these are only about 50 years old.
</p>

</aside>

</section>
<section id="slide-orgcc3c0e6">
<h3 id="orgcc3c0e6">Revised Guideline</h3>
<p>
When defining our own operators, we are well-advised to stick to conventional<br />
or intuitive properties, <i>where they exist</i>.
</p>

<div class='vertspace2'></div>

<p>
Corollary: study history.
</p>

<p>
<i>A History of Mathematical Notations</i> by Florian Cajori
</p>

<aside class="notes">
<p>

</p>

</aside>

</section>
<section id="slide-org5b3c9f3">
<h3 id="org5b3c9f3">Operator overloading advice</h3>
<div class='vertspace2'></div>
<blockquote nil>
<p>"When in doubt, do as the <code>int</code>s do."</p>
<div></div><div class='author'>
<p>
&#x2013; Scott Meyers, <i>More Effective C++</i>
</p>
</div>
</blockquote>

<aside class="notes">
<p>
<code>int</code> is well understood, and <code>int</code> is fast.
</p>

<p>
What are the principle reasons we might not like operator overloading? I think 2
reasons.
</p>

<p>
I don't like re-using operators to mean arbitrary, nonconventional things. (cf
trademarks)
</p>

<p>
I don't like the potential for operators to impose performance costs through
hidden computation and through binary functions calls rather than n-ary.
</p>

</aside>

</section>
<section id="slide-orgc137a50">
<h3 id="orgc137a50">Operator overloading</h3>
<div class='vertspace2'></div>
<p>
When in doubt, do what <code>operator+</code> does?
</p>

<aside class="notes">
<p>
Maybe we should try to find the most "normal" operator and see if we can divine
some guidelines for overloading.
</p>

</aside>

</section>
<section id="slide-org6e4bac8">
<h3 id="org6e4bac8"><code>operator+</code> Properties</h3>
<div class='vertspace2'></div>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<tr>
<th class="org-left">Property</td>
<th class="org-left">Math(s)</td>
<th class="org-left">C++</td>
</tr>
<tr>
<td class="org-left"><div class="fragment" data-fragment-index="1">Closed</div></td>
<td class="org-left"><div class="fragment" data-fragment-index="1">&#x2714;</div></td>
<td class="org-left"><div class="fragment" data-fragment-index="5">&#x2717; (overflow)</div></td>
</tr>
<tr>
<td class="org-left"><div class="fragment" data-fragment-index="2">Associative</div></td>
<td class="org-left"><div class="fragment" data-fragment-index="2">&#x2714;</div></td>
<td class="org-left"><div class="fragment" data-fragment-index="6">&#x2717; (floating point)</div></td>
</tr>
<tr>
<td class="org-left"><div class="fragment" data-fragment-index="3">Commutative</div></td>
<td class="org-left"><div class="fragment" data-fragment-index="3">&#x2714;</div></td>
<td class="org-left"><div class="fragment" data-fragment-index="7">&#x2717; (strings)</div></td>
</tr>
<tr>
<td class="org-left"><div class="fragment" data-fragment-index="4">Has Identity</div></td>
<td class="org-left"><div class="fragment" data-fragment-index="4">&#x2714;</div></td>
<td class="org-left"><div class="fragment" data-fragment-index="8" style="float: inline-start;">&#x2714;</div><div class="fragment" data-fragment-index="13">&#x2714;(+0.0, -0.0!)</div></td>
</tr>
</tbody>
</table>

<aside class="notes">
<p>
What are the properties of addition?
</p>

<p>
It has all these properties when we apply it to an unsigned int, but&#x2026;
</p>

<p>
This tells me that programming has its own conventions separate from the
conventions of mathematics.
</p>

<p>
On the other hand, we do try to follow mathematical conventions mostly.
</p>

</aside>

</section>
<section id="slide-org6790287">
<h3 id="org6790287">Operators in Compiler History</h3>
<font size="3">(from https://jeffreykegler.github.io/personal/timeline_v3)</font>

<p>
1956: The IT Compiler
</p>
<blockquote  class="fragment appear">
<p>
"&#x2026;the first really <i>useful</i> compiler."
</p>
<div></div><div class='author'>
<p>
&#x2013; Donald E Knuth
</p>
</div>
</blockquote>

<br/>
<p class="fragment appear">
But it didn't have operator precedence as we know it today.
</p>
<blockquote  class="fragment appear">
<p>
"The lack of operator priority &#x2026; in the IT language was the most frequent
single cause of errors by the users of that compiler."
</p>
<div></div><div class='author'>
<p>
&#x2013; Donald E Knuth
</p>
</div>
</blockquote>

<aside class="notes">
<p>
IT (Internal Translator) was a compiler for the IBM 650. Perhaps the first
compiler that we would recognize as one in the modern sense. (Translating
human-readable source into machine code.)
</p>

</aside>

</section>
<section id="slide-orgcd2f8d0">
<h3 id="orgcd2f8d0">Why?</h3>
<p>
Because operators convey meaning that names don't.
</p>

<ul>
<li>associativity/commutativity</li>
<li>precedence</li>
<li>distributive law</li>

</ul>

<p>
Because operators allow concision/readability.
</p>

<p>
Because operators allow expressions to be manipulated.
</p>

<aside class="notes">
<p>
I hope I've given a pretty good answer to "why should we use operators?"
</p>

<p>
Because operators convey meaning not only about <i>operations</i> but about the
<i>types</i> they act upon.
</p>

<p>
Because well-used operators allow readability through concision.
</p>

<p>
Because operators are at the heart of <i>expressions</i> and expressions allow
manipulation to provide better readability and perhaps performance.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org1020184">
<h2 id="org1020184">Mathematical Principles</h2>
<p>
Which mathematical conventions should we follow, then?
</p>

<p>
A selection, in approximate order of importance&#x2026;
</p>

<aside class="notes">
<p>
Here are some conventions I think are important.
</p>

</aside>

</section>
<section id="slide-org33759b2">
<h3 id="org33759b2">Probably the most important</h3>
<ul>
<li>Logical contrariety of <code>==</code> and <code>!=</code></li>

</ul>

<p>
Break this one at your peril!
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">bool</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">==</span><span style="color: #707183;">(</span><span style="color: #a020f0;">const</span> <span style="color: #228b22;">T</span>&amp; <span style="color: #a0522d;">x</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">T</span>&amp; <span style="color: #a0522d;">y</span><span style="color: #707183;">)</span> <span style="color: #a020f0;">noexcept</span>
<span style="color: #707183;">{</span>
  <span style="color: #0000ff;">...</span>
<span style="color: #707183;">}</span>

<span style="color: #228b22;">bool</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">!=</span><span style="color: #707183;">(</span><span style="color: #a020f0;">const</span> <span style="color: #228b22;">T</span>&amp; <span style="color: #a0522d;">x</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">T</span>&amp; <span style="color: #a0522d;">y</span><span style="color: #707183;">)</span> <span style="color: #a020f0;">noexcept</span>
<span style="color: #707183;">{</span>
  <span style="color: #a020f0;">return</span> !<span style="color: #7388d6;">(</span>x==y<span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<aside class="notes">
<p>
If you break the opposite-ness of equality and inequality, you will not pass a
code review from me.
</p>

<p>
If you make an equality operator, you had better make inequality mean its
opposite.
</p>

</aside>

</section>
<section id="slide-org09ad718">
<h3 id="org09ad718">Very important</h3>
<ul>
<li>Associativity of <code>+</code> and <code>*</code></li>

</ul>

<div class="org-src-container">

<pre  class="src src-c++">assert<span style="color: #707183;">(</span><span style="color: #7388d6;">(</span>a + b<span style="color: #7388d6;">)</span> + c == a + <span style="color: #7388d6;">(</span>b + c<span style="color: #7388d6;">)</span><span style="color: #707183;">)</span>;
</pre>
</div>

<p>
Almost all mathematical objects we work with in C++ obey this, so if you violate
this, your code could be very surprising.
</p>

<aside class="notes">
<p>
Associativity is one of the key properties that allows us to manipulate
expressions.
</p>

<p>
Unfortunately we don't yet have the machinery in C++ to take advantage of this
fully. As we will see in a couple of slides' time.
</p>

</aside>

</section>
<section id="slide-org41a4fce">
<h3 id="org41a4fce">Still fairly important</h3>
<ul>
<li>Law of the excluded middle</li>

</ul>

<p>
Either a given proposition is true, or its negation is true.<br />
<i>tertium non datur</i>
</p>

<div class="org-src-container">

<pre  class="src src-c++">assert<span style="color: #707183;">(</span>a &gt; b || a &lt;= b<span style="color: #707183;">)</span>;
</pre>
</div>

<p>
Mostly true (but notably not for <code>float</code>).
</p>

<aside class="notes">
<p>
For ordering: this makes thinking about ordering a whole lot easier.
</p>

</aside>

</section>
<section id="slide-orgf84aca8">
<h3 id="orgf84aca8">Nice to have</h3>
<div class='vertspace2'></div>

<ul>
<li>Commutativity of <code>+</code></li>

</ul>

<p>
I think it's <i>probably</i> too late to "fix" <code>std::string</code> by giving it <code>operator*</code>.
</p>

<p>
(ಠ_ಠ at <code>std::reduce</code>)
</p>

<aside class="notes">
<p>
Commutativity is a nice property in general, and unfortunately it's required for
<code>reduce</code>. Mathematically only associativity is required for <code>reduce</code> but the
standard requires commutativity. I think because of implementation concerns
around vectorization.
</p>

</aside>

</section>
<section id="slide-orge23c71e">
<h3 id="orge23c71e">Nice to have</h3>
<div class='vertspace2'></div>

<ul>
<li>Distribution of <code>*</code> over <code>+</code></li>

</ul>

<p>
This (or something similar) helps users of your code to manipulate expressions.
</p>

<aside class="notes">
<p>
These last two properties allude to a mathematical structure called a ring.
</p>

<p>
We could also cite AND and XOR operations as forming another ring.
</p>

<p>
Think also about de Morgan's laws. We are used to manipulating expressions in
certain ways - particularly arithmetic and boolean expressions. If we choose to
overload operators for our own types that are supposed to behave in arithmetic
ways, it behooves us to follow the expectations of users.
</p>

</aside>

</section>
<section id="slide-orgae3125a">
<h3 id="orgae3125a">Can go either way</h3>
<div class='vertspace2'></div>

<ul>
<li>Closedness of <code>+</code></li>

</ul>

<p>
But if you don't have closure over your type, you had better know why.
</p>

<aside class="notes">
<p>
This is one of those things that is maybe so obvious that we don't think about
it. When you add together two things, you get a thing of the same type. After
all, in C++, unlike in mathematics, even the division operator is closed over
integral types.
</p>

<p>
But in fact relaxing this rule can be good design. And that leads us to affine
spaces.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org0c7d51f">
<h2 id="org0c7d51f">Affine Spaces</h2>
<div class='vertspace2'></div>


<div class="figure">
<p><object type="image/svg+xml" data="affine_space.svg" class="org-svg" width="500px">
Sorry, your browser does not support SVG.</object>
</p>
</div>

<aside class="notes">
<p>
An affine space is a vector space that makes a distinction between a point
(position) and a vector (translation).
</p>

<p>
Now, it's quite possible - even likely - that we can represent these things the
same way. And it's likely that the space has an origin. We could say that points
are the same as vectors, measured from the origin.
</p>

</aside>

</section>
<section id="slide-org669a3e0">
<h3 id="org669a3e0">Affine Spaces</h3>
<p>
Types and operators working together as a team.
</p>

<ul>
<li>a set of points (values of type 1)</li>
<li>difference between two points is a vector (value of type 2)</li>
<li>operations that relate points to vectors</li>
<li>no need for an origin</li>

</ul>

<aside class="notes">
<p>
But an affine space relaxes that requirement. In an affine space we have no need
for an origin. And it's useful to use two different types to represent these
ideas.
</p>

<p>
Because when we use two different types, it lets us see more clearly what the
useful operations are between those types.
</p>

<p>
The standard library has a couple of good examples.
</p>

</aside>

</section>
<section id="slide-orgcefef0e">
<h3 id="orgcefef0e"><code>chrono</code>: <code>time_point</code> and <code>duration</code></h3>
<p>
In <code>chrono</code>, time is a one-dimensional affine space.
</p>

<ul>
<li><code>time_point</code> is a point</li>
<li><code>duration</code> is a vector</li>

</ul>

<aside class="notes">
<p>
It is meaningless to add points. Subtracting points from each other yields a
vector - <code>duration</code> is the "difference type". And vectors can be added to
points.
</p>

<p>
Vectors may be added to or subtracted from each other. So we can think of
addition as closed over vectors.
</p>

</aside>

</section>
<section id="slide-org40a676c">
<h3 id="org40a676c"><code>chrono</code> as an affine space</h3>
<p>
Thinking of it this way helps us to define the operations that make sense.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #228b22;">time_point</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">+</span><span style="color: #707183;">(</span><span style="color: #228b22;">time_point</span>, duration<span style="color: #707183;">)</span>;
<span style="color: #228b22;">time_point</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">-</span><span style="color: #707183;">(</span><span style="color: #228b22;">time_point</span>, duration<span style="color: #707183;">)</span>;

<span style="color: #228b22;">duration</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">-</span><span style="color: #707183;">(</span><span style="color: #228b22;">time_point</span>, <span style="color: #228b22;">time_point</span><span style="color: #707183;">)</span>;

<span style="color: #228b22;">duration</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">+</span><span style="color: #707183;">(</span><span style="color: #228b22;">duration</span>, <span style="color: #228b22;">duration</span><span style="color: #707183;">)</span>;
<span style="color: #228b22;">duration</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">-</span><span style="color: #707183;">(</span><span style="color: #228b22;">duration</span>, <span style="color: #228b22;">duration</span><span style="color: #707183;">)</span>;
<span style="color: #228b22;">duration</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">*</span><span style="color: #707183;">(</span><span style="color: #228b22;">duration</span>, rep<span style="color: #707183;">)</span>;
<span style="color: #228b22;">duration</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">/</span><span style="color: #707183;">(</span><span style="color: #228b22;">duration</span>, rep<span style="color: #707183;">)</span>;

<span style="color: #228b22;">duration</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">%</span><span style="color: #707183;">(</span><span style="color: #228b22;">duration</span>, <span style="color: #228b22;">duration</span><span style="color: #707183;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
Addition (subtraction) is closed over vectors.
</p>

<p>
We can add/subtract vectors to points. But when we subtract a point from another
point, we get a vector.
</p>

<p>
We can scale vectors.
</p>

<p>
Since we're in one dimension, it makes sense to compute the remainder when
dividing one vector by another.
</p>

<p>
If we have more than one dimension, maybe e.g. dot means something, and maybe
we could offer that functionality.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org2c22138">
<h2 id="org2c22138">Why Overload Conventionally?</h2>
<p>
Helps users with:
</p>
<ul>
<li>intuition</li>
<li>manipulation</li>
<li>properties</li>

</ul>

<aside class="notes">
<p>
The answer to "why be conventional?" has two sides.
</p>

<p>
If our types are mathematical (and they almost always are, in some way),
identifying the properties helps us.
</p>

<p>
It helps users by analogy with what they know. It helps them intuit properties.
</p>

</aside>

</section>
<section id="slide-org37f7835">
<h3 id="org37f7835">Why Overload Conventionally?</h3>
<p>
Helps implementers/designers identify:
</p>
<ul>
<li>a complete basis</li>
<li>minimality vs convenience</li>
<li>efficiency</li>
<li>in general, the space of types and operations</li>

</ul>

<aside class="notes">
<p>
More importantly, as implementers, it puts our types and operations on a firm
foundation. It helps us identify missing parts of the design. It helps us think
about which operations are likely to be fast and which are not. It helps us
explore the design space of our types. It helps us know what is a minimal set of
basis operations and which operations are for convenience.
</p>

</aside>

</section>
<section id="slide-orgbbfb528">
<h3 id="orgbbfb528">Why Be Conventional?</h3>
<p>
It helps us take advantage of compositionality built into<br />
the standard library and the language.
</p>

<ul>
<li><code>std::accumulate</code>, <code>std::reduce</code>, etc</li>
<li>fold expressions</li>

</ul>

<aside class="notes">
<p>
With C++17, we got an extra reason to like overloading operators.
</p>

<p>
Fold expressions are now in the language!
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgd956d1c">
<h2 id="orgd956d1c">New stuff in C++17</h2>
<aside class="notes">
<p>
So let's talk a bit about fold expressions and what else is new in C++17 related
to operators.
</p>

</aside>

</section>
<section id="slide-org4f8600c">
<h3 id="org4f8600c">Fold expressions</h3>
<p>
In C++17, <i>fold expressions</i> fold (reduce) a parameter pack over a binary
operator.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">typename</span><span style="color: #0000ff;">...</span> Args<span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">output</span><span style="color: #707183;">(</span><span style="color: #228b22;">Args</span>&amp;&amp;<span style="color: #0000ff;">...</span> args<span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
  <span style="color: #a020f0;">return</span> <span style="color: #7388d6;">(</span><span style="color: #008b8b;">std</span>::cout &lt;&lt; <span style="color: #0000ff;">...</span> &lt;&lt; args<span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<aside class="notes">
<p>
This is a binary left fold.
</p>

<p>
i.e. the operator used acts as if it is left-associative. In this case it's
obvious if you consider the type of <code>std::cout</code> - the fold expression must be
grouping to the left.
</p>

<p>
Most of our operators are left associative, and most of the time, if you don't
care, you want this left-to-right grouping.
</p>

</aside>

</section>
<section id="slide-org4085301">
<h3 id="org4085301">Fold expressions</h3>
<p>
Choosing left- or right- fold is usually about commutativity rather than
associativity.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">typename</span> <span style="color: #228b22;">Matrix</span>, <span style="color: #a020f0;">typename</span><span style="color: #0000ff;">...</span> Args<span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">multiply_on_right</span><span style="color: #707183;">(</span><span style="color: #228b22;">Matrix</span>&amp;&amp; <span style="color: #a0522d;">m</span>, <span style="color: #228b22;">Args</span>&amp;&amp;<span style="color: #0000ff;">...</span> args<span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
  <span style="color: #a020f0;">return</span> <span style="color: #7388d6;">(</span><span style="color: #228b22;">m</span> * <span style="color: #0000ff;">...</span> * args<span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>

<span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">typename</span> <span style="color: #228b22;">Matrix</span>, <span style="color: #a020f0;">typename</span><span style="color: #0000ff;">...</span> Args<span style="color: #707183;">&gt;</span>
<span style="color: #a020f0;">auto</span> <span style="color: #0000ff;">multiply_on_left</span><span style="color: #707183;">(</span><span style="color: #228b22;">Matrix</span>&amp;&amp; <span style="color: #a0522d;">m</span>, <span style="color: #228b22;">Args</span>&amp;&amp;<span style="color: #0000ff;">...</span> args<span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
  <span style="color: #a020f0;">return</span> <span style="color: #7388d6;">(</span><span style="color: #228b22;">args</span> * <span style="color: #0000ff;">...</span> * m<span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<aside class="notes">
<p>
Sometimes you do care. Usually the operation itself is associative (e.g. matrix
multiplication) so it doesn't matter which way the pack is folded, except in the
application to the initial argument. In this case it's not commutative - so it's
different whether we apply our transformation by multiplying on the left or the
right.
</p>

</aside>

</section>
<section id="slide-org8ec1c3a">
<h3 id="org8ec1c3a">Fold expressions</h3>
<p>
Unary fold expressions also exist&#x2026;
</p>

<p>
But are mostly useful with operators that shouldn't really be overloaded.
</p>

<aside class="notes">
<p>
I'm not going to dwell on unary folds, although they exist too, because they are
most usefully used with logical and, logical or, and comma operators, and it's
generally not advisable to overload those operators.
</p>

</aside>

</section>
<section id="slide-org2864431">
<h3 id="org2864431">New evaluation semantics</h3>
<p>
C++17 changed semantics for overloading:
</p>
<ul>
<li><code>operator&amp;&amp;</code></li>
<li><code>operator||</code></li>
<li><code>operator,</code></li>

</ul>

<p>
<i>Evaluation order guarantees</i> P0145
</p>

<aside class="notes">
<p>
Why? Well let's briefly cover how C++17 changed them, in case you have to deal
with code that overloads them.
</p>

<p>
It was long the case in C++ that the order of evaluation of arguments to a
function (or operator) is indeterminate. That is still true in most cases.
</p>

<p>
However, P0145 changed that for these three operators. Since C++17 these three
operators evaluate their operands in left-to-right sequence, even when
overloaded.
</p>

<p>
But note: <code>operator&amp;&amp;</code> and <code>operator||</code> still don't short circuit when
overloaded!
</p>

</aside>

</section>
<section id="slide-org8b10c5c">
<h3 id="org8b10c5c">Operators in C++17</h3>
<ul>
<li>Associativity is important for leveraging fold expressions</li>
<li>Non-commutativity affects the choice of fold</li>
<li>You probably still don't want to mess with <code>&amp;&amp;</code> <code>||</code> and <code>,</code></li>

</ul>

<aside class="notes">
<p>
Unlocking fold expressions is a great reason to use operator overloading (as
opposed to the other choice of using <code>std::accumulate</code>) especially if your
operator is not commutative. Because it's more of a pain to write a right-fold
with <code>std::accumulate</code> and reverse iterators.
</p>

</aside>

</section>
<section id="slide-org0ecce8e">
<h3 id="org0ecce8e">Right-fold, old-style</h3>
<p>
Something like this.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #006400;">// </span><span style="color: #006400;">Assuming we have a class Foo with a non-commutative operation</span>

<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">right_multiplies</span> <span style="color: #707183;">{</span>
  <span style="color: #a020f0;">template</span> <span style="color: #7388d6;">&lt;</span><span style="color: #a020f0;">typename</span> <span style="color: #228b22;">T</span><span style="color: #7388d6;">&gt;</span>
  <span style="color: #228b22;">T</span> <span style="color: #a020f0;">operator</span><span style="color: #7388d6;">()</span><span style="color: #7388d6;">(</span><span style="color: #228b22;">T</span> <span style="color: #a0522d;">t1</span>, <span style="color: #228b22;">T</span> <span style="color: #a0522d;">t2</span><span style="color: #7388d6;">)</span> <span style="color: #a020f0;">const</span> <span style="color: #7388d6;">{</span>
    <span style="color: #a020f0;">return</span> operation<span style="color: #909183;">(</span>t2, t1<span style="color: #909183;">)</span>;
  <span style="color: #7388d6;">}</span>
<span style="color: #707183;">}</span>;

<span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">template</span> <span style="color: #7388d6;">&lt;</span><span style="color: #a020f0;">class</span><span style="color: #7388d6;">&gt;</span> <span style="color: #a020f0;">typename</span> <span style="color: #228b22;">Container</span> = <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">initializer_list</span><span style="color: #707183;">&gt;</span>
<span style="color: #228b22;">Foo</span> <span style="color: #0000ff;">right_fold_old</span><span style="color: #707183;">(</span><span style="color: #228b22;">Foo</span> <span style="color: #a0522d;">init</span>, <span style="color: #228b22;">Container</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">Foo</span><span style="color: #7388d6;">&gt;</span> <span style="color: #a0522d;">c</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
    <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">std</span>::accumulate<span style="color: #7388d6;">(</span><span style="color: #008b8b;">std</span>::crbegin<span style="color: #909183;">(</span>c<span style="color: #909183;">)</span>, <span style="color: #008b8b;">std</span>::crend<span style="color: #909183;">(</span>c<span style="color: #909183;">)</span>, init, right_multiplies<span style="color: #909183;">{}</span><span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>

<span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">sum</span> = right_fold_old<span style="color: #707183;">(</span>foo_init, <span style="color: #7388d6;">{</span>foo1, foo2, foo3<span style="color: #7388d6;">}</span><span style="color: #707183;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
Here's what we had to do to write a right-fold before C++17.
</p>

<p>
Something like this. The right-multiplies is a class we need to write to apply
the operator the right way around. If we want this to be generic, we'd also need
to pass <code>operation</code> to right_multiplies as a template argument. And we need to
use reverse iterators, and we need to deal with a container. The call site is
not as nice as it could be.
</p>

<p>
If you don't use operator overloading, right-folds are a real pain.
</p>

<p>
But if you do use operators&#x2026;
</p>

</aside>

</section>
<section id="slide-org7d2c54b">
<h3 id="org7d2c54b">Right-fold, new-style</h3>
<p>
Something like this.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #006400;">// </span><span style="color: #006400;">Assuming we have a class Foo with a non-commutative operator*</span>

<span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">typename</span><span style="color: #0000ff;">...</span> Args<span style="color: #707183;">&gt;</span>
<span style="color: #228b22;">Foo</span> <span style="color: #0000ff;">right_fold_new</span><span style="color: #707183;">(</span><span style="color: #228b22;">Foo</span> <span style="color: #a0522d;">init</span>, <span style="color: #228b22;">Args</span>&amp;&amp;<span style="color: #0000ff;">...</span> args<span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
    <span style="color: #a020f0;">return</span> <span style="color: #7388d6;">(</span><span style="color: #228b22;">args</span> * <span style="color: #0000ff;">...</span> * init<span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>

<span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">sum</span> = right_fold_new<span style="color: #707183;">(</span>foo_init, foo1, foo2, foo3<span style="color: #707183;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
It's much nicer. It's much clearer in intent.
</p>

<p>
So much for C++17, let's have a little look at what's coming in C++20.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org970c086">
<h2 id="org970c086">New in C++20</h2>
<p>
We get a whole new operator!
</p>

<p>
The three-way comparison operator.
</p>

<p>
<code>operator&lt;=&gt;</code>
</p>

<p>
AKA "the spaceship operator". [expr.spaceship]
</p>

<aside class="notes">
<p>
You've probably heard something about this.
</p>

<p>
It's designed to provide a three-way comparison on x and y: something like
strcmp does. So informally, if x is less than y, return less than zero, if x
equals y, return zero, if x is greater than y, return greater than zero.
</p>

<p>
Disclaimer: everything in this section is very new - so new it's not yet
implemented in some cases. I'm going to try to tell you about what I think I
know so far.
</p>

</aside>

</section>
<section id="slide-org446c5e2">
<h3 id="org446c5e2"><code>operator&lt;=&gt;</code> 101</h3>
<p>
<code>#include &lt;compare&gt;</code> to get 5 types [cmp.categories]:
</p>

<ul>
<li><code>std::strong_equality</code></li>
<li><code>std::weak_equality</code></li>

<li><code>std::strong_ordering</code></li>
<li><code>std::weak_ordering</code></li>

<li><code>std::partial_ordering</code></li>

</ul>

<p>
A call to <code>operator&lt;=&gt;</code> returns a value of one of these types.
</p>

<aside class="notes">
<p>
<code>operator&lt;=&gt;</code> is designed to replace all the equality and ordering operators we
have today. A type that defines <code>operator&lt;=&gt;</code>
</p>

<p>
Strong vs weak here is what the standard calls substitutability: the idea that
if x has a relation to y, f(x) has that same relation to f(y).
</p>

<p>
I've got some examples of each type here to help understand.
</p>

</aside>

</section>
<section id="slide-org8da55be">
<h3 id="org8da55be">Equality</h3>
<p>
<code>std::strong_equality</code> means values that are <code>equal</code> are indistinguishable.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">strong_equality</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">&lt;=</span>&gt;<span style="color: #707183;">(</span><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">type_info</span> <span style="color: #a0522d;">a</span>, <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">type_info</span> <span style="color: #a0522d;">b</span><span style="color: #707183;">)</span>;
</pre>
</div>

<p>
<code>std::weak_equality</code> means values that are <code>equivalent</code> may be distinguishable.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">weak_equality</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">&lt;=</span>&gt;<span style="color: #707183;">(</span><span style="color: #008b8b;">std</span>::<span style="color: #008b8b;">filesystem</span>::<span style="color: #228b22;">path</span> <span style="color: #a0522d;">a</span>, <span style="color: #008b8b;">std</span>::<span style="color: #008b8b;">filesystem</span>::<span style="color: #228b22;">path</span> <span style="color: #a0522d;">b</span><span style="color: #707183;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
Disclaimer: these examples &amp; relations aren't actually in the standard (yet).
They're just examples.
</p>

<p>
std::type_info has no ordering, but does have strong equality.
</p>

<p>
It's actually pretty difficult to find weak_equality types in the standard.
Filesystem paths may be equivalent in the sense that they refer to the same
object on disk, but they may differ because they may be relative or absolute,
and contain extraneous .. components or the like.
</p>

<p>
(When we put this in the standard, we may decide that paths have an ordering
because they "are" strings&#x2026; I'm not sure that would be right.)
</p>

</aside>

</section>
<section id="slide-org2646a16">
<h3 id="org2646a16">Ordering</h3>
<p>
A <i>total</i> ordering means exactly one of the following is true:
</p>
<ul>
<li>a &gt; b</li>
<li>a == b</li>
<li>a &lt; b</li>

</ul>

<p>
<code>std::strong_ordering</code> is a total ordering <i>with</i> substitutability.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">template</span> <span style="color: #707183;">&lt;</span><span style="color: #a020f0;">typename</span> <span style="color: #228b22;">T</span><span style="color: #707183;">&gt;</span>
<span style="color: #008b8b;">std</span>::<span style="color: #228b22;">strong_ordering</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">&lt;=</span>&gt;<span style="color: #707183;">(</span><span style="color: #a020f0;">typename</span> <span style="color: #008b8b;">std</span>::<span style="color: #008b8b;">vector</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">T</span><span style="color: #7388d6;">&gt;</span>::<span style="color: #228b22;">iterator</span> <span style="color: #a0522d;">a</span>,
                                 <span style="color: #a020f0;">typename</span> <span style="color: #008b8b;">std</span>::<span style="color: #008b8b;">vector</span><span style="color: #7388d6;">&lt;</span><span style="color: #228b22;">T</span><span style="color: #7388d6;">&gt;</span>::<span style="color: #228b22;">iterator</span> <span style="color: #a0522d;">b</span><span style="color: #707183;">)</span>;
</pre>
</div>

<p>
<code>std::weak_ordering</code> is a total ordering <i>without</i> substitutability.
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">weak_ordering</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">&lt;=</span>&gt;<span style="color: #707183;">(</span><span style="color: #a020f0;">const</span> <span style="color: #228b22;">CIString</span>&amp; <span style="color: #a0522d;">a</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">CIString</span>&amp; <span style="color: #a0522d;">b</span><span style="color: #707183;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
Of course the iterators have to be into the same vector; there are preconditions
here.
</p>

<p>
Probably not many examples of <code>weak_ordering</code> in the standard either. Case
insensitive strings is a possible example.
</p>

</aside>

</section>
<section id="slide-org33a69ec">
<h3 id="org33a69ec">Ordering</h3>
<p>
<code>std::partial_ordering</code> means it's possible that none of the following is true:
</p>
<ul>
<li>a &gt; b</li>
<li>a == b</li>
<li>a &lt; b</li>

</ul>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">partial_ordering</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">&lt;=</span>&gt;<span style="color: #707183;">(</span><span style="color: #228b22;">float</span> <span style="color: #a0522d;">a</span>, <span style="color: #228b22;">float</span> <span style="color: #a0522d;">b</span><span style="color: #707183;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
Perhaps the canonical example of a partial order is float, because of the
presence of NaNs.
</p>

<p>
So with all this, how does using the spaceship operator have the potential to
change things? Let's look at a representative bit of code.
</p>

</aside>

</section>
<section id="slide-org4d8dd20">
<h3 id="org4d8dd20">Case study: Last year's SCM Challenge</h3>
<p>
Challenge: write a case insensitive string class that implements<br />
all 6 comparison operations.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">ci_compare_equal</span> <span style="color: #707183;">{</span>
    <span style="color: #228b22;">bool</span> <span style="color: #a020f0;">operator</span><span style="color: #7388d6;">()</span><span style="color: #7388d6;">(</span><span style="color: #228b22;">char</span> <span style="color: #a0522d;">x</span>, <span style="color: #228b22;">char</span> <span style="color: #a0522d;">y</span><span style="color: #7388d6;">)</span> <span style="color: #a020f0;">const</span> <span style="color: #7388d6;">{</span>
        <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">std</span>::toupper<span style="color: #909183;">(</span>x<span style="color: #909183;">)</span> == <span style="color: #008b8b;">std</span>::toupper<span style="color: #909183;">(</span>y<span style="color: #909183;">)</span>;
    <span style="color: #7388d6;">}</span>
<span style="color: #707183;">}</span>;
<span style="color: #a020f0;">struct</span> <span style="color: #228b22;">ci_compare_less</span> <span style="color: #707183;">{</span>
    <span style="color: #228b22;">bool</span> <span style="color: #a020f0;">operator</span><span style="color: #7388d6;">()</span><span style="color: #7388d6;">(</span><span style="color: #228b22;">char</span> <span style="color: #a0522d;">x</span>, <span style="color: #228b22;">char</span> <span style="color: #a0522d;">y</span><span style="color: #7388d6;">)</span> <span style="color: #a020f0;">const</span> <span style="color: #7388d6;">{</span>
        <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">std</span>::toupper<span style="color: #909183;">(</span>x<span style="color: #909183;">)</span> &lt; <span style="color: #008b8b;">std</span>::toupper<span style="color: #909183;">(</span>y<span style="color: #909183;">)</span>;
    <span style="color: #7388d6;">}</span>
<span style="color: #707183;">}</span>;

<span style="color: #a020f0;">inline</span> <span style="color: #228b22;">bool</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">==</span><span style="color: #707183;">(</span><span style="color: #a020f0;">const</span> <span style="color: #228b22;">CIString</span>&amp; <span style="color: #a0522d;">x</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">CIString</span>&amp; <span style="color: #a0522d;">y</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
    <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">std</span>::equal<span style="color: #7388d6;">(</span>x.s.cbegin<span style="color: #909183;">()</span>, x.s.cend<span style="color: #909183;">()</span>,
        y.s.cbegin<span style="color: #909183;">()</span>, y.s.cend<span style="color: #909183;">()</span>, ci_compare_equal<span style="color: #909183;">{}</span><span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>
<span style="color: #a020f0;">inline</span> <span style="color: #228b22;">bool</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">&lt;</span><span style="color: #707183;">(</span><span style="color: #a020f0;">const</span> <span style="color: #228b22;">CIString</span>&amp; <span style="color: #a0522d;">x</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">CIString</span>&amp; <span style="color: #a0522d;">y</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
    <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">std</span>::lexicographical_compare<span style="color: #7388d6;">(</span>x.s.cbegin<span style="color: #909183;">()</span>, x.s.cend<span style="color: #909183;">()</span>,
        y.s.cbegin<span style="color: #909183;">()</span>, y.s.cend<span style="color: #909183;">()</span>, ci_compare_less<span style="color: #909183;">{}</span><span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<aside class="notes">
<p>
This was the Stevens Capital Management challenge that was at last year's
CppCon. Here's more or less how I solved part of it.
</p>

<p>
The ci_compare_equal and ci_compare_less here were just structs with a function
call operator that do the obvious thing.
</p>

<p>
Anyway, once we have these two operators, we can implement the rest.
</p>

</aside>

</section>
<section id="slide-org5fa7b51">
<h3 id="org5fa7b51">Case study - continued</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">inline</span> <span style="color: #228b22;">bool</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">!=</span><span style="color: #707183;">(</span><span style="color: #a020f0;">const</span> <span style="color: #228b22;">CIString</span>&amp; <span style="color: #a0522d;">x</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">CIString</span>&amp; <span style="color: #a0522d;">y</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
    <span style="color: #a020f0;">return</span> !<span style="color: #7388d6;">(</span>x == y<span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>

<span style="color: #a020f0;">inline</span> <span style="color: #228b22;">bool</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">&gt;</span><span style="color: #707183;">(</span><span style="color: #a020f0;">const</span> <span style="color: #228b22;">CIString</span>&amp; <span style="color: #a0522d;">x</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">CIString</span>&amp; <span style="color: #a0522d;">y</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
    <span style="color: #a020f0;">return</span> y &lt; x;
<span style="color: #707183;">}</span>

<span style="color: #a020f0;">inline</span> <span style="color: #228b22;">bool</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">&lt;=</span><span style="color: #707183;">(</span><span style="color: #a020f0;">const</span> <span style="color: #228b22;">CIString</span>&amp; <span style="color: #a0522d;">x</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">CIString</span>&amp; <span style="color: #a0522d;">y</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
    <span style="color: #a020f0;">return</span> !<span style="color: #7388d6;">(</span>y &lt; x<span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>

<span style="color: #a020f0;">inline</span> <span style="color: #228b22;">bool</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">&gt;=</span><span style="color: #707183;">(</span><span style="color: #a020f0;">const</span> <span style="color: #228b22;">CIString</span>&amp; <span style="color: #a0522d;">x</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">CIString</span>&amp; <span style="color: #a0522d;">y</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
    <span style="color: #a020f0;">return</span> !<span style="color: #7388d6;">(</span>x &lt; y<span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<aside class="notes">
<p>
The canonical way to implement the comparison operators.
</p>

<p>
Note that we never do more than one operation (and possibly a not). e.g. When we
do <code>operator&lt;=</code>, we don't actually test <code>operator&lt;</code> and <code>operator==</code>.
</p>

<p>
You can copy-paste these with your own types, or template them: they never
change (prior to C++20).
</p>

<p>
Also note that all the comparison operators are free functions. I prefer to
write them this way because it puts the two arguments on an equal footing and
makes for better symmetry. And <code>operator==</code> and <code>operator&lt;</code> are friends only if
they need to be. (The rest never need to be.)
</p>

</aside>

</section>
<section id="slide-orgabdca54">
<h3 id="orgabdca54">So how did this change with C++20?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">inline</span> <span style="color: #008b8b;">std</span>::<span style="color: #228b22;">weak_ordering</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">&lt;=</span>&gt;<span style="color: #707183;">(</span><span style="color: #a020f0;">const</span> <span style="color: #228b22;">CIString</span>&amp; <span style="color: #a0522d;">x</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">CIString</span>&amp; <span style="color: #a0522d;">y</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
    <span style="color: #a020f0;">return</span> <span style="color: #008b8b;">std</span>::lexicographical_compare_3way<span style="color: #7388d6;">(</span>
        x.s.cbegin<span style="color: #909183;">()</span>, x.s.cend<span style="color: #909183;">()</span>, y.s.cbegin<span style="color: #909183;">()</span>, y.s.cend<span style="color: #909183;">()</span>,
        <span style="color: #909183;">[]</span> <span style="color: #909183;">(</span><span style="color: #228b22;">char</span> <span style="color: #a0522d;">x</span>, <span style="color: #228b22;">char</span> <span style="color: #a0522d;">y</span><span style="color: #909183;">)</span> <span style="color: #909183;">{</span>
            <span style="color: #a020f0;">const</span> <span style="color: #a020f0;">auto</span> diff = <span style="color: #008b8b;">std</span>::toupper<span style="color: #709870;">(</span>x<span style="color: #709870;">)</span> - <span style="color: #008b8b;">std</span>::toupper<span style="color: #709870;">(</span>y<span style="color: #709870;">)</span>;
            <span style="color: #a020f0;">return</span> <span style="color: #228b22;">diff</span> <span style="color: #709870;">&lt;</span> <span style="color: #008b8b;">0</span> ? <span style="color: #008b8b;">std</span>::<span style="color: #008b8b;">weak_ordering</span>::less :
              diff <span style="color: #709870;">&gt;</span> <span style="color: #008b8b;">0</span> ? <span style="color: #008b8b;">std</span>::<span style="color: #008b8b;">weak_ordering</span>::greater :
              <span style="color: #008b8b;">std</span>::<span style="color: #008b8b;">weak_ordering</span>::equivalent;
        <span style="color: #909183;">}</span><span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>
</pre>
</div>

<aside class="notes">
<p>
This operator now does everything. We're using the new
<code>lexicographical_compare_3way</code> algorithm which in turn uses a 3-way comparison
function. Notice that the lambda returns a value of type <code>std::weak_ordering</code>.
We could make <code>operator&lt;=&gt;</code> return <code>auto</code> if we wanted.C++20 gives us the
ability to use a non-capturing lambda here because now they can be
default-constructed.
</p>

<p>
But there's a problem here. What is it? This function does everything, but it
doesn't do equality efficiently. If we want that we still need to write it the
old way - and we can still provide <code>operator==</code> and <code>operator!=</code>. Unfortunately
there's no <code>std::equal_3way</code> yet.
</p>

</aside>

</section>
<section id="slide-org4427b07">
<h3 id="org4427b07"><code>operator&lt;=&gt;</code> guidelines</h3>
<p>
It's too new to switch to it yet (obviously - it's C++20).
</p>

<ul>
<li>library support is only just being figured out</li>
<li>no real implementations yet</li>
<li>issues with generic code/composition have to be worked out</li>
<li>perf pitfalls with sequence containers + naive usage</li>

</ul>

<aside class="notes">
<p>
Clearly there is some way to go yet on figuring out the rough edges of this
operator. It's very new.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org1ee65c3">
<h2 id="org1ee65c3">Straying from Convention</h2>
<blockquote nil>
<p>
"When I use a word," Humpty Dumpty said, in rather a scornful tone, "it means
just what I choose it to mean—neither more nor less." "The question is," said
Alice, "whether you can make words mean so many different things." "The question
is," said Humpty Dumpty, "which is to be master—that's all.”
</p>
<div></div><div class='author'>
<p>
&#x2013; Lewis Carroll, Through the Looking Glass
</p>
</div>
</blockquote>

<aside class="notes">
<p>
So we've talked about being conventional with operators. Now let's talk about
what we can gain from breaking from the mold. Let's have some fun.
</p>

</aside>

</section>
<section id="slide-org66da4bc">
<h3 id="org66da4bc">DSLs</h3>
<p>
The primary use of a DSL is in the construction of (otherwise) complex objects.
</p>

<ul>
<li>terser</li>
<li>simpler</li>
<li>manipulable</li>

</ul>

<p>
The use of template expressions may also provide performance gains.
</p>

<p>
UDLs are a natural fit for DSLs.
</p>

<aside class="notes">
<p>
DSLs are where operators work together with types to make code easier to
understand.
</p>

<p>
Typically they shine where the objects and classes you want to construct are not
difficult to understand (you never want that), but where it would be
prohibitively wordy to construct them. We're trying to achieve readability.
</p>

</aside>

</section>
<section id="slide-org4445a1d">
<h3 id="org4445a1d">Readability</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span><span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span>;
v.reserve<span style="color: #707183;">(</span><span style="color: #008b8b;">5</span><span style="color: #707183;">)</span>;
v.push_back<span style="color: #707183;">(</span><span style="color: #008b8b;">1</span><span style="color: #707183;">)</span>;
v.push_back<span style="color: #707183;">(</span><span style="color: #008b8b;">2</span><span style="color: #707183;">)</span>;
v.push_back<span style="color: #707183;">(</span><span style="color: #008b8b;">3</span><span style="color: #707183;">)</span>;
v.push_back<span style="color: #707183;">(</span><span style="color: #008b8b;">4</span><span style="color: #707183;">)</span>;
v.push_back<span style="color: #707183;">(</span><span style="color: #008b8b;">5</span><span style="color: #707183;">)</span>;
</pre>
</div>
<p>
vs
</p>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #008b8b;">std</span>::<span style="color: #228b22;">vector</span><span style="color: #707183;">&lt;</span><span style="color: #228b22;">int</span><span style="color: #707183;">&gt;</span> <span style="color: #a0522d;">v</span><span style="color: #707183;">{</span><span style="color: #008b8b;">1</span>,<span style="color: #008b8b;">2</span>,<span style="color: #008b8b;">3</span>,<span style="color: #008b8b;">4</span>,<span style="color: #008b8b;">5</span><span style="color: #707183;">}</span>;
</pre>
</div>

<aside class="notes">
<p>
We have the square-brackets operator, and the parens operator; here we have the
curly brackets/braces operator! initializer_list is a DSL for initialization.
</p>

<p>
This is why we want DSLs: they give us easier to read, declarative code. When we
overload operators, we allow the users of our library to form expressions rather
than having to sequence statements.
</p>

</aside>

</section>
<section id="slide-orga3212b2">
<h3 id="orga3212b2"><code>chrono</code> dates</h3>
<p>
A DSL with one operator and two UDLs.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">using</span> <span style="color: #a020f0;">namespace</span> <span style="color: #008b8b;">std</span>::<span style="color: #008b8b;">chrono</span>;

<span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> today_us = September/<span style="color: #008b8b;">25</span>/<span style="color: #008b8b;">2018</span>;
<span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> today_uk = <span style="color: #008b8b;">25d</span>/September/<span style="color: #008b8b;">2018</span>;
<span style="color: #a020f0;">constexpr</span> <span style="color: #a020f0;">auto</span> today = <span style="color: #008b8b;">2018y</span>/September/<span style="color: #008b8b;">25</span>;
</pre>
</div>

<aside class="notes">
<p>
<code>chrono</code> provides us with the only possible defence of using the US system for
writing dates: it's one character fewer.
</p>

<p>
Consider alternative ways of constructing dates and they all end up using
operators (mostly operator+), and being much more verbose. So the use of
<code>operator/</code> works really well, especially together with the UDLs.
</p>

<p>
It's not "mathematically conventional" but it is datewise-conventional.
</p>

</aside>

</section>
<section id="slide-org425d077">
<h3 id="org425d077"><code>filesystem::path</code></h3>
<p>
A DSL with one operator.
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">using</span> <span style="color: #a020f0;">namespace</span> <span style="color: #008b8b;">std</span>::<span style="color: #008b8b;">filesystem</span>;

<span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">home_prefix</span> = path<span style="color: #707183;">{</span><span style="color: #b22222;">"/home"</span><span style="color: #707183;">}</span>;
<span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">my_home_dir</span> = home_prefix / <span style="color: #b22222;">"bdeane"</span>;
</pre>
</div>

<aside class="notes">
<p>
Another non-conventional operator, but it works brilliantly. There's no
confusion with division here. It's taking what we already do with strings -
concatenation - and making it easier.
</p>

<p>
I've spent far too much of my life dealing with the presence or absence of
trailing slashes in path names. <code>operator/</code> just does the right thing.
</p>

</aside>

</section>
<section id="slide-orge49aec2">
<h3 id="orge49aec2">[Boost.]SML</h3>
<p>
(Disclaimer: SML isn't a Boost library)
</p>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">tcp_release</span> <span style="color: #a020f0;">final</span> <span style="color: #707183;">{</span>
  <span style="color: #a020f0;">auto</span> <span style="color: #a020f0;">operator</span><span style="color: #7388d6;">()</span><span style="color: #7388d6;">()</span> <span style="color: #a020f0;">const</span> <span style="color: #7388d6;">{</span>
    <span style="color: #a020f0;">using</span> <span style="color: #a020f0;">namespace</span> <span style="color: #008b8b;">sml</span>;
    <span style="color: #a020f0;">return</span> make_transition_table<span style="color: #909183;">(</span>
      *<span style="color: #b22222;">"established"</span>_s + <span style="color: #228b22;">event</span><span style="color: #709870;">&lt;</span>release<span style="color: #709870;">&gt;</span>          / send_fin  = <span style="color: #b22222;">"fin wait 1"</span>_s,
       <span style="color: #b22222;">"fin wait 1"</span>_s  + <span style="color: #228b22;">event</span><span style="color: #709870;">&lt;</span>ack<span style="color: #709870;">&gt;</span> <span style="color: #709870;">[</span> is_valid <span style="color: #709870;">]</span>             = <span style="color: #b22222;">"fin wait 2"</span>_s,
       <span style="color: #b22222;">"fin wait 2"</span>_s  + <span style="color: #228b22;">event</span><span style="color: #709870;">&lt;</span>fin<span style="color: #709870;">&gt;</span> <span style="color: #709870;">[</span> is_valid <span style="color: #709870;">]</span> / send_ack  = <span style="color: #b22222;">"timed wait"</span>_s,
       <span style="color: #b22222;">"timed wait"</span>_s  + <span style="color: #228b22;">event</span><span style="color: #709870;">&lt;</span>timeout<span style="color: #709870;">&gt;</span>                      = X
    <span style="color: #909183;">)</span>;
  <span style="color: #7388d6;">}</span>
<span style="color: #707183;">}</span>;
</pre>
</div>

<aside class="notes">
<p>
There's a lot going on here. This is a concise definition of a state machine.
We've got a UDL, a constant, and five different operator overloads working
together. There is a lot of type machinery in the background, but the result is
readable.
</p>

<p>
It's also very malleable. This is what operators give us: readability, yes, but
more so, easy manipulation. Adding a state or changing a state is easy here
because the terse, transparent syntax makes it easy to reason about the state
machine.
</p>

<p>
Let's think about choices we could have made in operators here. (The operators
follow UML syntax.) If you want to know more, see Kris's talk at 9am Wed.
</p>

</aside>

</section>
<section id="slide-org32ff1fc">
<h3 id="org32ff1fc">Operators and Monads</h3>
<p>
What's the biggest problem with monads?
</p>

<ul>
<li class="fragment appear">understanding them?</li>
<li class="fragment appear">explaining them?</li>
<li class="fragment appear">CT wonks?</li>
<li class="fragment appear">the sudden urge to try to make everything monadic?</li>

</ul>

<aside class="notes">
<p>
Monads are cropping up in a few places now. <code>std::optional</code>, <code>std::expected</code>,
<code>std::future</code>&#x2026;
</p>

<p>
None of these things.
</p>

<p>
This is a talk about operators&#x2026;
</p>

</aside>

</section>
<section id="slide-orga9c3ae6">
<h3 id="orga9c3ae6">The main problem with monads</h3>
<p>
In C++, <code>operator&gt;&gt;=</code> is <i>right associative</i>!
</p>

<p>
What operator overloads are we going to use is we want to compose things
monadically?
</p>

<aside class="notes">
<p>
Monads make a lot of sense for modelling some things. But which operators should
we use for monadic operations?
</p>

<p>
In C++ there aren't many good choices. And this goes back to the top of the talk.
</p>

</aside>

</section>
<section id="slide-org30ad81e">
<h3 id="org30ad81e">Operator overloading and futures</h3>
<div class='vertspace2'></div>
<img src='futures.svg'/>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #006400;">// </span><span style="color: #006400;">imaginary-ish code</span>
<span style="color: #228b22;">my_future</span><span style="color: #707183;">&lt;</span>A<span style="color: #707183;">&gt;</span> <span style="color: #0000ff;">f</span><span style="color: #707183;">(</span>X<span style="color: #707183;">)</span>;
<span style="color: #228b22;">my_future</span><span style="color: #707183;">&lt;</span>B<span style="color: #707183;">&gt;</span> <span style="color: #0000ff;">g1</span><span style="color: #707183;">(</span>A<span style="color: #707183;">)</span>;
<span style="color: #228b22;">my_future</span><span style="color: #707183;">&lt;</span>C<span style="color: #707183;">&gt;</span> <span style="color: #0000ff;">g2</span><span style="color: #707183;">(</span>A<span style="color: #707183;">)</span>;
<span style="color: #228b22;">my_future</span><span style="color: #707183;">&lt;</span>D<span style="color: #707183;">&gt;</span> <span style="color: #0000ff;">h</span><span style="color: #707183;">(</span>B, C<span style="color: #707183;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
Imagine a simple composition of asynchronous functions that return futures.
</p>

<p>
Notice that their composition can itself be viewed as a function from X to
future&lt;D&gt;.
</p>

<p>
I'm not making any assumptions about how <code>my_future</code> is implemented here.
</p>

</aside>

</section>
<section id="slide-org2084c87">
<h3 id="org2084c87">Operator Overloading and Futures</h3>
<div class='vertspace2'></div>
<div class="org-src-container">

<pre  class="fragment appear"><span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">fut</span> = f<span style="color: #707183;">()</span>;
<span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">split1</span> = fut.then<span style="color: #707183;">(</span>g1<span style="color: #707183;">)</span>;
<span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">split2</span> = fut.then<span style="color: #707183;">(</span>g2<span style="color: #707183;">)</span>;
<span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">fut2</span> = when_all<span style="color: #707183;">(</span>split1, split2<span style="color: #707183;">)</span>.then<span style="color: #707183;">(</span>h<span style="color: #707183;">)</span>;
</pre>
</div>
<div class="org-src-container">

<pre  class="fragment appear"><span style="color: #a020f0;">auto</span> <span style="color: #a0522d;">fut</span> = f<span style="color: #707183;">()</span> &gt;= <span style="color: #707183;">(</span>g1 &amp; g2<span style="color: #707183;">)</span> &gt;= h;
</pre>
</div>
<p class="fragment appear">
Operator overloading can clarify the computational structure when combining
futures/promises.
</p>

<aside class="notes">
<p>
Here's again why operators are important: when we can use operators to compose
futures, it becomes easier to see the computational structure of the
composition.
</p>

<p>
Business logic vs mechanism of concurrency vs strategy of parallelism.
</p>

<p>
The question is, what to use for an operator. This is one of the real problems
with operator overloading: lack of choice almost forces lack of conventionality.
</p>

<p>
I don't have a good sense of what will become conventional in monadic
operations, if anything, but I don't think this is a bad way to go.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orgcd5f6a6">
<h2 id="orgcd5f6a6">Mechanics</h2>
<aside class="notes">
<p>
Now I want to cover a few mechanics of writing operator overloads, choices and
preferences.
</p>

</aside>

</section>
<section id="slide-orgd9b210c">
<h3 id="orgd9b210c">Free or not?</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Foo</span> <span style="color: #707183;">{</span>
  <span style="color: #228b22;">Foo</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">+</span><span style="color: #7388d6;">(</span><span style="color: #a020f0;">const</span> <span style="color: #228b22;">Foo</span>&amp; <span style="color: #a0522d;">other</span><span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>;
</pre>
</div>

<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Foo</span> <span style="color: #707183;">{</span>
<span style="color: #707183;">}</span>;

<span style="color: #228b22;">Foo</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">+</span><span style="color: #707183;">(</span><span style="color: #a020f0;">const</span> <span style="color: #228b22;">Foo</span>&amp; <span style="color: #a0522d;">x</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">Foo</span>&amp; <span style="color: #a0522d;">y</span><span style="color: #707183;">)</span>;
</pre>
</div>

<aside class="notes">
<p>
First question: which should you prefer, and why?
</p>

<p>
Normal rules apply: prefer a free function if you can. Free functions promote
encapsulation: keeping the basis functions of your class minimal, complete and
stable is desirable, and building further convenience with free functions
promotes encapsulation: relying on the class interface and not the
implementation.
</p>

<p>
Free functions also have the slightly more nuanced advantage that they put their
operands on an "equal footing" mentally. This is more natural to think about
especially in the case of a commutative operation.
</p>

</aside>

</section>
<section id="slide-orgefca4af">
<h3 id="orgefca4af">Free and non-free</h3>
<div class="org-src-container">

<pre  class="src src-c++"><span style="color: #a020f0;">struct</span> <span style="color: #228b22;">Foo</span> <span style="color: #707183;">{</span>
  <span style="color: #228b22;">Foo</span>&amp; <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">+=</span><span style="color: #7388d6;">(</span><span style="color: #a020f0;">const</span> <span style="color: #228b22;">Foo</span>&amp; <span style="color: #a0522d;">other</span><span style="color: #7388d6;">)</span>;
<span style="color: #707183;">}</span>;

<span style="color: #228b22;">Foo</span> <span style="color: #a020f0;">operator</span><span style="color: #0000ff;">+</span><span style="color: #707183;">(</span><span style="color: #a020f0;">const</span> <span style="color: #228b22;">Foo</span>&amp; <span style="color: #a0522d;">x</span>, <span style="color: #a020f0;">const</span> <span style="color: #228b22;">Foo</span>&amp; <span style="color: #a0522d;">y</span><span style="color: #707183;">)</span> <span style="color: #707183;">{</span>
  <span style="color: #228b22;">Foo</span> <span style="color: #a0522d;">r</span><span style="color: #7388d6;">{</span>x<span style="color: #7388d6;">}</span>;
  r += y;
  <span style="color: #a020f0;">return</span> r;
<span style="color: #707183;">}</span>
</pre>
</div>

<aside class="notes">
<p>
Binary operators generally should be implemented in terms of their assignment
counterparts. This is part of providing a complete set of operators and is an
application of the DRY principle.
</p>

<p>
In fact, the "operator assignment" operators need not be member functions. I
don't know why. Plain <code>operator=</code> has to be a member function.
</p>

</aside>

</section>
<section id="slide-org3fdc998">
<h3 id="org3fdc998">Don't forget qualifiers</h3>
<p>
Operators are functions, so you should apply all the normal rules of writing
functions.
</p>

<ul>
<li><code>constexpr</code></li>
<li><code>const</code></li>
<li><code>noexcept</code></li>
<li>parameter types</li>
<li>return type</li>

</ul>

<aside class="notes">
<p>
Hopefully this is all obvious. Think about parameter types. Think about the
return type. Qualify appropriately.
</p>

<p>
This slide is of course a talk in its own right.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-orga2b2a4e">
<h2 id="orga2b2a4e">Guidelines Redux</h2>
<p>
Let's recap.
</p>

</section>
<section id="slide-org3490956">
<h3 id="org3490956">When to use operator overloading</h3>
<p>
Use operators when:
</p>
<ul>
<li class="fragment appear">you have a natural binary function that combines your types</li>
<li class="fragment appear">your types obey mathematical principles (associativity, etc)</li>
<li class="fragment appear">you want users to be able to manipulate expressions</li>
<li class="fragment appear">you want to make complex construction easier</li>
<li class="fragment appear">you want users to intuit properties of your types</li>

</ul>

<aside class="notes">
<p>
Don't force things.
</p>

<p>
Do exploit the power that operators give to you as an implementer and to your
users.
</p>

</aside>

</section>
<section id="slide-orga129aad">
<h3 id="orga129aad">When not to use operator overloading</h3>
<p>
Don't use (only) operators when:
</p>
<ul>
<li class="fragment appear">you can provide better perf with an n-ary function</li>
<li class="fragment appear">they aren't yet ready for primetime (<code>operator&lt;=&gt;</code>)</li>

</ul>

<aside class="notes">
<p>
This is one of the most important points against dogmatic operator overloading.
Compilers can't collapse multiple binary operations into an n-ary operation. If
you can, and it's important to you for better performance, by all means provide
that interface. Don't <i>constrain</i> your users to only binary operations.
</p>

<p>
As far as the spaceship operator goes, watch this space. I think it needs to
evolve a bit more. Which is fair enough.
</p>

</aside>

</section>
<section id="slide-org6d273e9">
<h3 id="org6d273e9">Don't</h3>
<ul>
<li class="fragment appear">break contrariety of <code>operator==</code> and <code>operator!=</code></li>
<li class="fragment appear">break associativity</li>
<li class="fragment appear">be afraid to overload just one operator, if it makes sense (<code>operator/</code>)</li>
<li class="fragment appear">overload <code>operator&amp;&amp;</code> <code>operator||</code> <code>operator,</code> even with P0145</li>
<li class="fragment appear">pick weird operators if your type <i>is</i> mathematical</li>

</ul>

<aside class="notes">
<p>
P0145: remember you don't get short circuit behaviour with &amp;&amp; and ||.
</p>

<p>
And there is no good convention for the comma operator that I know of.
</p>

</aside>

</section>
<section id="slide-orgb2f841d">
<h3 id="orgb2f841d">Do</h3>
<ul>
<li class="fragment appear">use conventions <i>other</i> than mathematical ones</li>
<li class="fragment appear">consider distinguishing your types to leverage affine spaces</li>
<li class="fragment appear">use operators for non-commutative operations to leverage fold expressions</li>
<li class="fragment appear">use UDLs as a counterpart to operators to help with construction</li>
<li class="fragment appear">provide the whole set of related operators if you provide one</li>

</ul>

<aside class="notes">
<p>
The technique of separating types is a really powerful one for clarifying your
design. Even if you don't end up with an affine space, it's worth trying to
separate types and see where it leads.
</p>

<p>
Provide the complete set of operators (including all variations of types). It's
just going to end up annoying people if you don't. Often, type variation means
handling <code>std::string</code> and <code>char *</code> possibilities, and <code>string_view</code> can help
here.
</p>

</aside>

</section>
</section>
<section>
<section id="slide-org74e9a86">
<h2 id="org74e9a86">Thank you</h2>
<p class="fragment appear">
Questions?
</p>

<p class="fragment appear">
<del>Comments thinly disguised as questions?</del>
</p>

<p class="fragment appear">
Pitchforks &amp; torches?
</p>
</section>
</section>
</div>
</div>
<script src="../reveal.js/lib/js/head.min.js"></script>
<script src="../reveal.js/js/reveal.js"></script>

<script>
// Full list of configuration options available here:
// https://github.com/hakimel/reveal.js#configuration
Reveal.initialize({

controls: true,
progress: true,
history: true,
center: true,
slideNumber: 'c/t',
rollingLinks: false,
keyboard: true,
overview: true,
width: 1600,
height: 900,
margin: 0.10,
minScale: 0.50,
maxScale: 2.50,

theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
transition: Reveal.getQueryHash().transition || 'none', // default/cube/page/concave/zoom/linear/fade/none
transitionSpeed: 'default',
multiplex: {
    secret: '', // null if client
    id: '', // id, obtained from socket.io server
    url: '' // Location of socket.io server
},

// Optional libraries used to extend on reveal.js
dependencies: [
 { src: '../reveal.js/lib/js/classList.js', condition: function() { return !document.body.classList; } },
 { src: '../reveal.js/plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: '../reveal.js/plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
 { src: '../reveal.js/plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
 { src: '../reveal.js/plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }]
});
</script>
</body>
</html>
